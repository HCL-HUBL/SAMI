singularity {
    enabled = true
    autoMounts = true
}

process {
    // Let user define scratching behavior
	scratch = { params.scratch }
	
	// Max number of retries, whatever the reason
	maxRetries = { params.maxRetries }
	
	// Processes with dynamic ressource limits retry for any reason
	withLabel: retriable {
		errorStrategy = 'retry'
	}
	
	// Processes without dynamic ressource limits retry only on 'Resource temporarily unavailable'
	withLabel: nonRetriable {
		errorStrategy = {
			if(task.exitStatus == 255) {
				sleep(task.attempt * 10 + Math.random() * 5 as long)
				return 'retry'
			} else {
				return 'terminate'
			}
		}
	}
	
	// Dynamic ressource limits
	withName: fastq {
		time = { params.fixedTime == '' ? 5.minute : params.fixedTime }
		memory = 500.MB
	}
	withName: cutadapt {
		time = { params.fixedTime == '' ? 20.minute * task.attempt : params.fixedTime }
		memory = { 1.GB + 1.GB * task.attempt }
	}
	withName: fastqc_raw {
		time = { params.fixedTime == '' ? 15.minute + 30.minute * task.attempt : params.fixedTime }
		memory = { 3.GB + 1.GB * task.attempt }
	}
	withName: fastqc_trimmed {
		time = { params.fixedTime == '' ? 15.minute + 30.minute * task.attempt : params.fixedTime }
		memory = { 3.GB + 1.GB * task.attempt }
	}
	withName: star_index {
		time = { params.fixedTime == '' ? 3.hour : params.fixedTime }
		memory = 45.GB
	}
	withName: star_pass1 {
		time = { params.fixedTime == '' ? 1.hour * task.attempt : params.fixedTime }
		memory = { 30.GB + 5.GB * task.attempt }
	}
	withName: umi_stat_and_consensus {
		time = { params.fixedTime == '' ? 1.hour * task.attempt : params.fixedTime }
		memory = { 5.GB * task.attempt }
	}
	withName: umi_plot {
		time = { params.fixedTime == '' ? 1.minute * task.attempt : params.fixedTime }
		memory = { 500.MB * task.attempt }
	}
	withName: umi_table {
		time = { params.fixedTime == '' ? 1.minute * task.attempt : params.fixedTime }
		memory = { 500.MB * task.attempt }
	}
	withName: star_reindex {
		time = { params.fixedTime == '' ? 1.hour + 1.hour * task.attempt : params.fixedTime }
		memory = { 40.GB + 5.GB * task.attempt }
	}
	withName: star_pass2 {
		time = { params.fixedTime == '' ? 30.minute + 60.minute * task.attempt : params.fixedTime }
		memory = { 30.GB + 5.GB * task.attempt }
	}
	withName: insertsize_table {
		time = { params.fixedTime == '' ? 2.minute * task.attempt : params.fixedTime }
		memory = { 1.GB * task.attempt }
	}
	withName: indexfasta {
		time = { params.fixedTime == '' ? 5.minute * task.attempt : params.fixedTime }
		memory = { 5.GB * task.attempt }
	}
	withName: merge_filterbam {
		time = { params.fixedTime == '' ? 30.minute + 30.minute * task.attempt : params.fixedTime }
		memory = { 20.GB + 5.GB * task.attempt }
	}
	withName: markduplicates {
		time = { params.fixedTime == '' ? 15.minute * task.attempt : params.fixedTime }
		memory = { 5.GB * task.attempt }
	}
	withName: bam_sort {
		time = { params.fixedTime == '' ? 1.hour + 1.hour * task.attempt : params.fixedTime }
		memory = { 3.GB + 1.GB * task.attempt }
	}
	withName: duplication_umi_based {
		time = { params.fixedTime == '' ? 30.minute + 30.minute * task.attempt : params.fixedTime }
		memory = { 500.MB * task.attempt }
	}
	// withName: filterDuplicates {
		// time = TODO
		// memory = TODO 
	// }
	// withName: COSMIC {
		// time = TODO
		// memory = TODO 
	// }
	// withName: splitN {
		// time = TODO
		// memory = TODO 
	// }
	// withName: BQSR {
		// time = TODO
		// memory = TODO 
	// }
	// withName: Mutect2 {
		// time = TODO
		// memory = TODO 
	// }
	withName: refflat {
		time = { params.fixedTime == '' ? 15.minute : params.fixedTime }
		memory = { 4.GB * task.attempt }
	}
	withName: rrna_interval {
		time = { params.fixedTime == '' ? 15.minute : params.fixedTime }
		memory = 500.MB
	}
	withName: rnaseqmetrics {
		time = { params.fixedTime == '' ? 30.minute + 60.minute * task.attempt : params.fixedTime }
		memory = { 3.GB + 1.GB * task.attempt }   // FIXME : 10 GB vmem according to Nextflow
	}
	withName: featurecounts {
		time = { params.fixedTime == '' ? 1.hour * task.attempt : params.fixedTime }
		memory = { 750.MB * task.attempt }
	}
	withName: edgeR {
		time = { params.fixedTime == '' ? 15.minute : params.fixedTime }
		memory = 1.GB
	}
	withName: insertsize {
		time = { params.fixedTime == '' ? 10.minute * task.attempt : params.fixedTime }
		memory = { 500.MB * task.attempt }
	}
	withName: secondary {
		time = { params.fixedTime == '' ? 1.hour * task.attempt : params.fixedTime }
		memory = { 500.MB * task.attempt }
	}
	withName: softClipping {
		time = { params.fixedTime == '' ? 30.minute * task.attempt : params.fixedTime }
		memory = { 500.MB * task.attempt }
	}
	withName: multiqc {
		time = { params.fixedTime == '' ? 20.minute : params.fixedTime }
		memory = 4.GB
	}
	withName: annotation {
		time = { params.fixedTime == '' ? 10.minute * task.attempt : params.fixedTime }
		memory = { 1.GB + 1.GB * task.attempt }
	}
	withName: splicing_collect {
		time = { params.fixedTime == '' ? 10.minute * task.attempt : params.fixedTime }
		memory = { 10.GB + 5.GB * task.attempt }
	}
	withName: splicing_filter {
		time = { params.fixedTime == '' ? 30.minute * task.attempt : params.fixedTime }
		memory = { 10.GB + 5.GB * task.attempt }
	}
}

