singularity {
    enabled = true
    autoMounts = true
}

process {
    // Let user define scratching behavior
	scratch = { params.scratch }
	
	// Max number of retries, whatever the reason
	maxRetries = { params.maxRetries }
	
	// Processes with dynamic ressource limits retry for any reason
	withLabel: retriable {
		errorStrategy = 'retry'
	}
	
	// Processes without dynamic ressource limits retry only on 'Resource temporarily unavailable'
	withLabel: nonRetriable {
		errorStrategy = {
			if(task.exitStatus == 255) {
				sleep(task.attempt * 10 + Math.random() * 5 as long)
				return 'retry'
			} else {
				return 'terminate'
			}
		}
	}
	
	// Dynamic ressource limits
	withName: FASTQ {
		time = { params.fixedTime == '' ? 5.minute : params.fixedTime }
		memory = 50.MB
	}
	withName: cutadapt {
		time = { params.fixedTime == '' ? 20.minute * task.attempt : params.fixedTime }
		memory = { 1.GB + 1.GB * task.attempt }
	}
	withName: FastQC {
		time = { params.fixedTime == '' ? 15.minute + 30.minute * task.attempt : params.fixedTime }
		memory = { 3.GB + 1.GB * task.attempt }
	}
	withName: STAR_index {
		time = { params.fixedTime == '' ? 3.hour : params.fixedTime }
		memory = 45.GB
	}
	withName: STAR_pass1 {
		time = { params.fixedTime == '' ? 1.hour * task.attempt : params.fixedTime }
		memory = { 25.GB + 5.GB * task.attempt }
	}
	withName: umi_stat_and_consensus {
		time = { params.fixedTime == '' ? 20.minute * task.attempt : params.fixedTime }
		memory = { 10.GB + 5.GB * task.attempt }
	}
	withName: umi_plot {
		time = { params.fixedTime == '' ? 1.minute * task.attempt : params.fixedTime }
		memory = { 500.MB * task.attempt }
	}
	withName: umi_table {
		time = { params.fixedTime == '' ? 1.minute * task.attempt : params.fixedTime }
		memory = { 500.MB * task.attempt }
	}
	withName: STAR_reindex {
		time = { params.fixedTime == '' ? 1.hour + 1.hour * task.attempt : params.fixedTime }
		memory = { 40.GB + 5.GB * task.attempt }
	}
	withName: STAR_pass2 {
		time = { params.fixedTime == '' ? 30.minute + 60.minute * task.attempt : params.fixedTime }
		memory = { 30.GB + 5.GB * task.attempt }
	}
	withName: insertSize_table {
		time = { params.fixedTime == '' ? 1.minute * task.attempt : params.fixedTime }
		memory = { 500.MB * task.attempt }
	}
	// withName: indexFASTA {
		// time = TODO
		// memory = TODO
	// }
	withName: merge_filterBam {
		time = { params.fixedTime == '' ? 5.minute * task.attempt : params.fixedTime }
		memory = { 25.GB + 5.GB * task.attempt }
	}
	// withName: markDuplicates {
		// time = TODO
		// memory = TODO 
	// }
	withName: BAM_sort {
		time = { params.fixedTime == '' ? 1.hour + 1.hour * task.attempt : params.fixedTime }
		memory = { 3.GB + 1.GB * task.attempt }
	}
	withName: duplication_UMI_based {
		time = { params.fixedTime == '' ? 5.minute * task.attempt : params.fixedTime }
		memory = { 500.MB * task.attempt }
	}
	// withName: filterDuplicates {
		// time = TODO
		// memory = TODO 
	// }
	// withName: COSMIC {
		// time = TODO
		// memory = TODO 
	// }
	// withName: splitN {
		// time = TODO
		// memory = TODO 
	// }
	// withName: BQSR {
		// time = TODO
		// memory = TODO 
	// }
	// withName: Mutect2 {
		// time = TODO
		// memory = TODO 
	// }
	withName: refFlat {
		time = { params.fixedTime == '' ? 15.minute : params.fixedTime }
		memory = 500.MB
	}
	withName: rRNA_interval {
		time = { params.fixedTime == '' ? 15.minute : params.fixedTime }
		memory = 500.MB
	}
	withName: rnaSeqMetrics {
		time = { params.fixedTime == '' ? 30.minute + 60.minute * task.attempt : params.fixedTime }
		memory = { 3.GB + 1.GB * task.attempt }   // FIXME : 10 GB vmem according to Nextflow
	}
	withName: featureCounts {
		time = { params.fixedTime == '' ? 1.hour * task.attempt : params.fixedTime }
		memory = { 750.MB * task.attempt }
	}
	withName: edgeR {
		time = { params.fixedTime == '' ? 15.minute : params.fixedTime }
		memory = 1.GB
	}
	withName: insertSize {
		time = { params.fixedTime == '' ? 10.minute * task.attempt : params.fixedTime }
		memory = { 500.MB * task.attempt }
	}
	withName: secondary {
		time = { params.fixedTime == '' ? 1.hour * task.attempt : params.fixedTime }
		memory = { 250.MB * task.attempt }
	}
	withName: MultiQC {
		time = { params.fixedTime == '' ? 20.minute : params.fixedTime }
		memory = 4.GB
	}
	withName: junctions {
		time = { params.fixedTime == '' ? 10.minute * task.attempt : params.fixedTime }
		memory = { 250.MB * task.attempt }
	}
	withName: splicing_collect {
		time = { params.fixedTime == '' ? 10.minute * task.attempt : params.fixedTime }
		memory = { 1.GB + 1.GB * task.attempt }
	}
	withName: splicing_filter {
		time = { params.fixedTime == '' ? 10.minute * task.attempt : params.fixedTime }
		memory = { 5.GB * task.attempt }
	}
}

